try {
    // ÉTAPE 1 : Récupération avec vérification de réponse
    const resp1 = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=EURUSDT');
    if (!resp1.ok) throw new Error('Limite API atteinte'); // Détecte l'erreur 429
    
    const data1 = await resp1.json();
    const p1 = parseFloat(data1.price);
    logs.innerHTML = `> ANALYSE INITIALE : ${p1.toFixed(5)}<br>` + logs.innerHTML;

    await new Promise(r => setTimeout(r, 2000));

    // ÉTAPE 2 : Seconde récupération
    const resp2 = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=EURUSDT');
    if (!resp2.ok) throw new Error('Limite API atteinte');
    
    const data2 = await resp2.json();
    const p2 = parseFloat(data2.price);

    // ÉTAPE 3 : Logique de signal
    const diff = p2 - p1;
    if (Math.abs(diff) < 0.00001) {
        sig.innerText = "NEUTRE";
        sig.style.color = "gray";
        logs.innerHTML = `> <span style="color:gray">[STABLE]</span> Signal ignoré.<br>` + logs.innerHTML;
    } else {
        const direction = diff > 0 ? "CALL" : "PUT";
        sig.innerText = direction;
        sig.style.color = direction === "CALL" ? "var(--win)" : "var(--loss)";
        document.getElementById('box').style.borderColor = sig.style.color;
        logs.innerHTML = `> <span style="color:var(--gold)">[MATTHIEU AI]</span> Signal ${direction} validé.<br>` + logs.innerHTML;
    }
} catch (e) {
    // Si l'erreur vient de l'actualisation ou de la limite
    logs.innerHTML = `> <span style="color:#ff0044">[ERREUR]</span> Serveur occupé. Attendez 5s.<br>` + logs.innerHTML;
    sig.innerText = "RECO...";
    sig.style.color = "orange";
}
