let balance = 10.00;
let lastPrice = 0;
let priceHistory = [];

// 1. Connexion au flux réel de Binance (BTC/USDT)
const socket = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@ticker");

socket.onmessage = (event) => {
    const data = JSON.parse(event.data);
    const currentPrice = parseFloat(data.c);
    
    // Garder un historique des prix pour l'analyse
    priceHistory.push(currentPrice);
    if(priceHistory.length > 50) priceHistory.shift(); 
    
    lastPrice = currentPrice;
};

async function startHFTScan() {
    const btn = document.getElementById('hft-btn');
    const scan = document.getElementById('hft-scan');
    const res = document.getElementById('hft-result');
    const idle = document.getElementById('hft-idle');
    const sig = document.getElementById('sig-val');
    const box = document.getElementById('box');
    const logs = document.getElementById('logs');
    const expText = document.getElementById('exp-timer');

    if (!lastPrice) {
        alert("Attente du flux de données Binance...");
        return;
    }

    btn.disabled = true;
    idle.style.display = 'none';
    res.style.display = 'none';
    scan.style.display = 'block';
    box.style.animation = "none";

    // Simulation visuelle du scan (3 secondes)
    let ms = 0;
    const startPrice = lastPrice; // On capture le prix au début du scan
    
    const msInt = setInterval(() => {
        ms += Math.random() * 12;
        document.getElementById('ms-counter').innerText = ms.toFixed(2) + " ms";
        document.getElementById('v-val').innerText = (Math.random() * 15 + 5).toFixed(1) + " MS";
    }, 40);

    setTimeout(() => {
        clearInterval(msInt);
        
        // 2. LOGIQUE DE SIGNAL RÉEL
        // On compare le prix actuel avec le prix d'il y a 3 secondes
        const endPrice = lastPrice;
        const diff = endPrice - startPrice;
        
        // Si la différence est trop faible, on force une direction basée sur la micro-tendance
        let direction = diff > 0 ? "CALL" : "PUT";
        
        scan.style.display = 'none';
        res.style.display = 'block';
        sig.innerText = direction;
        
        const color = direction === "CALL" ? "var(--win)" : "var(--loss)";
        sig.style.color = color;
        box.style.borderColor = color;
        box.style.animation = direction === "CALL" ? "pulse-win 2s infinite" : "pulse-loss 2s infinite";

        // Expiration logic
        let timeLeft = 60;
        expText.innerText = timeLeft + "s";
        
        // Update Logs avec le vrai changement de prix
        const changePercent = ((diff / startPrice) * 100).toFixed(4);
        logs.innerHTML = `> <span style="color:var(--gold)">[M-AI]</span> ${direction} détecté (Var: ${changePercent}%)<br>` + logs.innerHTML;

        // Cooldown
        let cd = 3;
        const cooldownInt = setInterval(() => {
            btn.innerText = `COOLDOWN (${cd}s)`;
            cd--;
            if(cd < 0) {
                clearInterval(cooldownInt);
                btn.disabled = false;
                btn.innerText = "SNIPE MOMENTUM";
            }
        }, 1000);

    }, 3000);
}
